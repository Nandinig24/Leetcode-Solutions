/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
// case1 tree
void ans(TreeNode* root, int c, vector<int>& v) {
        if (root == NULL || c < 0) {
            return;
        }
        if (c == 0) {
            v.push_back(root->val);
            return;
        }
        ans(root->left, c - 1, v);
        ans(root->right, c - 1, v);
    }
// case 2 ancestor
    int printDis(TreeNode* root, TreeNode* target, int k, vector<int>& v) {
        if (root == NULL)
            return -1;
        
        if (root == target) {
            ans(root, k, v);
            return 0;  // return distance
        }
        
        int dl = printDis(root->left, target, k, v);
        if (dl != -1) {
            if (dl + 1 == k) {    // ancestor is at distance k
                v.push_back(root->val);
            } else {
                ans(root->right, k - dl - 2, v);  // look in the right subtree
            }
            return 1 + dl;
        }
        
        int dr = printDis(root->right, target, k, v);
        if (dr != -1) {
            if (dr + 1 == k) {    // ancestor is at distance k
                v.push_back(root->val);
            } else {
                ans(root->left, k - dr - 2, v);  // look in the left subtree
            }
            return 1 + dr;
        }
        
        return -1; // target not found
    }
   
    
    
    
vector<int> distanceK(TreeNode* A, TreeNode* B, int C) {
    vector<int>v;
    // TreeNode* target = new TreeNode(B);  // create a temporary node for target value
        printDis(A, B, C, v);
        // delete target;  // clean up the temporary node
        return v;
}
};