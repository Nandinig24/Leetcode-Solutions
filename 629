class Solution {
public:
// bool display(vector<int> a, int n,int k){
//     int c=0;
//     for(int i=0;i<n;i++){
//         for(int j=i+1;j<n;j++){
//             if(a[i]>a[j])
//             c++;
//         }
//         }
//         if(c==k)
//         return true;

//         return false;
   
// }
//     int kInversePairs(int n, int k) {
//         vector<int>a;
//         for(int i=1;i<=n;i++)
//         a.push_back(i);
//         int c=0;

//     do{
//         if(display(a, n,k))
//         c++;
//     }while(next_permutation(a.begin(), a.end())); //Generate next permutation till it is not lexicographically largest
// return c;
//     }

const int MOD = 1000000007;

int kInversePairsUtil(int n, int k, vector<vector<int>>& memo) {
    if (n == 0) {
        return 0;
    }

    if (k == 0) {
        return 1; // Only one way to have 0 inversions, which is the sorted array itself.
    }

    if (memo[n][k] != -1) {
        return memo[n][k];
    }

    int count = 0;
    for (int i = 0; i <= min(k, n - 1); i++) {
        count = (count + kInversePairsUtil(n - 1, k - i, memo)) % MOD;
    }

    memo[n][k] = count;
    return count;
}

int kInversePairs(int n, int k) {
    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));

    return kInversePairsUtil(n, k, memo);
}

};