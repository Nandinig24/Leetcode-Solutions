class Solution {
public:
    // long long maximumSubarraySum(vector<int>& nums, int k) {
    //     long long ans=0;
    //     long long r=0;
    //     unordered_map<int,int>mp;
    //     for(int i=0;i<k;i++){
    //         mp[nums[i]]++;
    //         r+=nums[i];
    //     }
    //     if(mp.size()==k){
    //         ans=max(ans,r);
    //     }

    //     for(int i=k-1;i<nums.size();i++){
    //         r-=nums[i-k-1];
    //         mp[nums[i-k-1]]--;
    //         if(mp[nums[i-k-1]==0]){
    //             mp.erase(nums[i-k-1]);
    //         }
    //         if(mp.size()==k)
    //         ans=max(ans,r);
    //     }
    //     return ans;
        
    // }

    long long maximumSubarraySum(vector<int>& nums, int k) {
    long long ans = 0;
    long long r = 0;
    unordered_map<int, int> mp;
    
    // Sliding window approach
    for (int i = 0; i < k; i++) {
        mp[nums[i]]++;
        r += nums[i];
    }
    if (mp.size() == k) {
        ans = max(ans, r);
    }

    for (int i = k; i < nums.size(); i++) {
        r -= nums[i - k ]; // Adjusting the window by subtracting the leftmost element
        mp[nums[i - k]]--; // Removing the leftmost element from the map
        mp[nums[i]]++;
        r+=nums[i];
        if (mp[nums[i - k ]] == 0) {
            mp.erase(nums[i - k]);
        }
        if (mp.size() == k) {
            ans = max(ans, r);
        }
    }
    return ans;
}

};